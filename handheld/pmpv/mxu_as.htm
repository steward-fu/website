<!--
 ____________________________________________________________
|                                                            |
|    DESIGN + Pat Heard { http://fullahead.org }             |
|      DATE + 2006.09.12                                     |
| COPYRIGHT + Free use if this notice is kept in place.      |
|____________________________________________________________|

-->

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>司徒的教學網站</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta http-lowast="content-type" content="application/xhtml+xml; charset=UTF-8" />
  <meta name="author" content="fullahead.org" />
  <meta name="keywords" content="XHTML, CSS, template, FullAhead" />
  <meta name="description" content="A valid, XHTML 1.0 template" />
  <meta name="robots" content="index, follow, noarchive" />
  <meta name="googlebot" content="noarchive" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=0.1, maximum-scale=100.0"/>

  <link rel="shortcut icon" href="../../website.ico">
  <link rel="stylesheet" type="text/css" href="../../styles/shCore.css" />
  <link rel="stylesheet" type="text/css" href="../../styles/shThemeDefault.css" />
  <link rel="stylesheet" type="text/css" href="../../css/html.css" media="screen, projection, tv " />
  <link rel="stylesheet" type="text/css" href="../../css/layout.css" media="screen, projection, tv" />
  <link rel="stylesheet" type="text/css" href="../../css/print.css" media="print" />
  
  <script type="text/javascript" src="../../scripts/shCore.js"></script>
  <script type="text/javascript" src="../../scripts/shBrushBash.js"></script>

  <!-- Conditional comment to apply opacity fix for IE #content background.
       Invalid CSS, but can be removed without harming design -->
  <!--[if gt IE 5]>
  <link rel="stylesheet" type="text/css" href="css/ie.css" media="screen, projection, tv " />
  <![endif]-->
</head>

<body>
<script type="text/javascript">SyntaxHighlighter.all();</script>
<div id="wrapper">
<div id="content">
<script type="text/javascript" src="../../header.js"></script>
<div id="page">
<h3>PMP V</h3>
<p><b>mxu_as</b></p>
<hr size="1">
<p>
程式碼如下：
</p>
<pre class="brush:bash">
#!/bin/bash

#expand $1 | sed  's/^ \+//g' | \
awk '
BEGIN { FS="[, \t]+"
############################################################################################
#Common variables definition begins from here
############################################################################################
  MXINSN_OK=0; SPECIAL2="011100";
  MINOR0="MINOR0"; EXTEND="EXTEND";
  WW="WW"; LW="LW"; HW="HW"; XW="XW"; AA="AA"; AS="AS"; SA="SA"; SS="SS";
  PTN0="PTN0"; PTN1="PTN1"; PTN2="PTN2"; PTN3="PTN3";
#MXU enhance
  PTN4="PTN4"; PTN5="PTN5"; PTN6="PTN6"; PTN7="PTN7";
#&lt;------MNEMONIC SYMBOLs
  D16MUL="D16MUL"; D16MULF="D16MULF"; D16MAC="D16MAC"; D16MACF="D16MACF"; S16MAD="S16MAD";
  D16MADL="D16MADL"; Q16ADD="Q16ADD"; Q8MUL="Q8MUL"; Q8MAC="Q8MAC"; Q8MADL="Q8MADL";
  S32SFL="S32SFL"; Q8SAD="Q8SAD"; D32ADD="D32ADD"; D32ACC="D32ACC"; Q16ACC="Q16ACC";
  Q8ADDE="Q8ADDE"; Q8ACCE="Q8ACCE"; S32CPS="S32CPS"; D16CPS="D16CPS"; Q8ABD="Q8ABD";
  Q16SAT="Q16SAT"; D16AVG="D16AVG"; D16AVGR="D16AVGR"; Q8AVG="Q8AVG"; Q8AVGR="Q8AVGR";
  Q8ADD="Q8ADD"; S32MAX="S32MAX"; S32MIN="S32MIN"; D16MAX="D16MAX"; D16MIN="D16MIN";
  Q8MAX="Q8MAX"; Q8MIN="Q8MIN"; Q8SLT="Q8SLT"; D32SLL="D32SLL"; D32SLR="D32SLR";
  D32SARL="D32SARL"; D32SAR="D32SAR"; Q16SLL="Q16SLL"; Q16SLR="Q16SLR"; Q16SAR="Q16SAR";
  D32SLLV="D32SLLV"; D32SLRV="D32SLRV"; D32SARV="D32SARV"; Q16SLLV="Q16SLLV"; 
  Q16SLRV="Q16SLRV"; Q16SARV="Q16SARV"; D32SARW="D32SARW"; S32ALN="S32ALN"; S32M2I="S32M2I"; 
  S32I2M="S32I2M"; S32LDD="S32LDD"; S32STD="S32STD"; S32LDI="S32LDI"; S32SDI="S32SDI";
  S32LDDV="S32LDDV"; S32STDV="S32STDV"; S32LDIV="S32LDIV"; S32SDIV="S32SDIV"; 

#MXU enhance
  D16MULE="D16MULE"; D16MACE="D16MACE"; Q8MULSU="Q8MULSU"; Q8MACSU="Q8MACSU"; Q8MOVZ="Q8MOVZ";
  Q8MOVN="Q8MOVN"; D16MOVZ="D16MOVZ"; D16MOVN="D16MOVN"; S32MOVZ="S32MOVZ"; S32MOVN="S32MOVN";
  D32ACCM="D32ACCM"; D32ASUM="D32ASUM"; Q16ACCM="Q16ACCM"; D16ASUM="D16ASUM"; D8SUM="D8SUM";
  D8SUMC="D8SUMC"; S32SLT="S32SLT"; D16SLT="D16SLT"; Q8SLTU="Q8SLTU"; S32ALNI="S32ALNI";
  S32LUI="S32LUI"; S32NOR="S32NOR"; S32AND="S32AND"; S32OR="S32OR"; S32XOR="S32XOR";
  S32LDDVR="S32LDDVR"; S32STDVR="S32STDVR"; S32LDIVR="S32LDIVR"; S32SDIVR="S32SDIVR"; 
  S32LDDR="S32LDDR"; S32STDR="S32STDR"; S32LDIR="S32LDIR"; S32SDIR="S32SDIR";
  S8LDD="S8LDD"; S8STD="S8STD"; S8LDI="S8LDI"; S8SDI="S8SDI"; S32EXTR="S32EXTR";
  S32MUL="S32MUL"; S32MULU="S32MULU"; S32MADD="S32MADD"; S32MADDU="S32MADDU";
  S32MSUB="S32MSUB"; S32MSUBU="S32MSUBU"; S16LDD="S16LDD"; S16LDI="S16LDI";
  S16STD="S16STD"; S16SDI="S16SDI"; D32ADDC="D32ADDC"; Q16SCOP="Q16SCOP";
  LXW="LXW"; LXB="LXB"; LXBU="LXBU"; LXH="LXH"; LXHU="LXHU"; S32EXTRV="S32EXTRV";

#&lt;------XRF SYMBOL
  XR0="XR0"; XR1="XR1"; XR2="XR2"; XR3="XR3"; XR4="XR4"; XR5="XR5"; XR6="XR6"; XR7="XR7";
  XR8="XR8"; XR9="XR9"; XR10="XR10"; XR11="XR11"; XR12="XR12"; XR13="XR13"; XR14="XR14"; 
  XR15="XR15"; XR16="XR16";

#&lt;------GRF alias
  ZERO="ZERO"; AT="AT"; V0="V0"; V1="V1"; A0="A0"; A1="A1"; A2="A2"; A3="A3";
  T0="T0"; T1="T1"; T2="T2"; T3="T3"; T4="T4"; T5="T5"; T6="T6"; T7="T7";
  S0="S0"; S1="S1"; S2="S2"; S3="S3"; S4="S4"; S5="S5"; S6="S6"; S7="S7";
  T8="T8"; T9="T9"; K0="K0"; K1="K1"; GP="GP"; SP="SP"; S8="S8"; RA="RA";
  FP="FP";

#&lt;------Dual MUL/MAC/ADD16 pattern
  MUL_PTN[WW]="00"; MUL_PTN[LW]="01"; MUL_PTN[HW]="10"; MUL_PTN[XW]="11"; 
  MUL_PTN[0]="00"; MUL_PTN[1]="01"; MUL_PTN[2]="10"; MUL_PTN[3]="11"; 

#&lt;------MAC add/sub combinations
  MAC_AS[AA]="00"; MAC_AS[AS]="01"; MAC_AS[SA]="10"; MAC_AS[SS]="11";
  MAC_AS[0]="00";  MAC_AS[1]="01"; MAC_AS[2]="10"; MAC_AS[3]="11";

#&lt;------XRF encoding
  xrf[XR0]="0000"; xrf[XR1]="0001"; xrf[XR2]="0010"; xrf[XR3]="0011"; 
  xrf[XR4]="0100"; xrf[XR5]="0101"; xrf[XR6]="0110"; xrf[XR7]="0111";
  xrf[XR8]="1000"; xrf[XR9]="1001"; xrf[XR10]="1010"; xrf[XR11]="1011"; 
  xrf[XR12]="1100"; xrf[XR13]="1101"; xrf[XR14]="1110"; xrf[XR15]="1111";

#&lt;------GRF encoding
  grf[ZERO]="0"; grf[AT]="1"; grf[V0]="2"; grf[V1]="3"; grf[A0]="4"; grf[A1]="5"; 
  grf[A2]="6"; grf[A3]="7"; grf[T0]="8"; grf[T1]="9"; grf[T2]="10"; grf[T3]="11"; 
  grf[T4]="12"; grf[T5]="13"; grf[T6]="14"; grf[T7]="15"; grf[S0]="16"; grf[S1]="17"; 
  grf[S2]="18"; grf[S3]="19"; grf[S4]="20"; grf[S5]="21"; grf[S6]="22"; grf[S7]="23"; 
  grf[T8]="24"; grf[T9]="25"; grf[K0]="26"; grf[K1]="27"; grf[GP]="28"; grf[SP]="29"; 
  grf[S8]="30"; grf[RA]="31"; grf[FP]="30";  
  
#&lt;------MINOR and EXTEND field
  insn[D16MUL,MINOR0] =""; insn[D16MUL,EXTEND] ="001000";
  insn[D16MULF,MINOR0] =""; insn[D16MULF,EXTEND] ="001001";
  insn[D16MAC,MINOR0] =""; insn[D16MAC,EXTEND] ="001010";
  insn[D16MACF,MINOR0] =""; insn[D16MACF,EXTEND] ="001011";
  insn[D16MADL,MINOR0] =""; insn[D16MADL,EXTEND] ="001100";
  insn[S16MAD,MINOR0] =""; insn[S16MAD,EXTEND] ="001101";
  insn[Q16ADD,MINOR0] =""; insn[Q16ADD,EXTEND] ="001110";
  insn[Q8MUL,MINOR0] =""; insn[Q8MUL,EXTEND] ="111000";
  insn[Q8MAC,MINOR0] =""; insn[Q8MAC,EXTEND] ="111010";
  insn[Q8MADL,MINOR0] =""; insn[Q8MADL,EXTEND] ="111100";
  insn[Q8SAD,MINOR0] =""; insn[Q8SAD,EXTEND] ="111110";
  insn[D32ADD,MINOR0] =""; insn[D32ADD,EXTEND] ="011000";
  insn[D32ACC,MINOR0] =""; insn[D32ACC,EXTEND] ="011001";
  insn[Q16ACC,MINOR0] =""; insn[Q16ACC,EXTEND] ="011011";
  insn[Q8ADDE,MINOR0] =""; insn[Q8ADDE,EXTEND] ="011100";
  insn[Q8ACCE,MINOR0] =""; insn[Q8ACCE,EXTEND] ="011101";
  insn[D16CPS,MINOR0] ="010"; insn[D16CPS,EXTEND] ="000111";
  insn[Q8ABD,MINOR0] ="100"; insn[Q8ABD,EXTEND] ="000111";
  insn[Q16SAT,MINOR0] ="110"; insn[Q16SAT,EXTEND] ="000111";
  insn[D16AVG,MINOR0] ="010"; insn[D16AVG,EXTEND] ="000110";
  insn[D16AVGR,MINOR0] ="011"; insn[D16AVGR,EXTEND] ="000110";
  insn[Q8AVG,MINOR0] ="100"; insn[Q8AVG,EXTEND] ="000110";
  insn[Q8AVGR,MINOR0] ="101"; insn[Q8AVGR,EXTEND] ="000110";
  insn[Q8ADD,MINOR0] ="111"; insn[Q8ADD,EXTEND] ="000110";
  insn[D16MAX,MINOR0] ="010"; insn[D16MAX,EXTEND] ="000011";
  insn[D16MIN,MINOR0] ="011"; insn[D16MIN,EXTEND] ="000011";
  insn[Q8MAX,MINOR0] ="100"; insn[Q8MAX,EXTEND] ="000011";
  insn[Q8MIN,MINOR0] ="101"; insn[Q8MIN,EXTEND] ="000011";
  insn[Q8SLT,MINOR0] ="110"; insn[Q8SLT,EXTEND] ="000011";
  insn[D32SLL,MINOR0] =""; insn[D32SLL,EXTEND] ="110000";
  insn[D32SLR,MINOR0] =""; insn[D32SLR,EXTEND] ="110001";
  insn[D32SARL,MINOR0] =""; insn[D32SARL,EXTEND] ="110010";
  insn[D32SAR,MINOR0] =""; insn[D32SAR,EXTEND] ="110011";
  insn[Q16SLL,MINOR0] =""; insn[Q16SLL,EXTEND] ="110100";
  insn[Q16SLR,MINOR0] =""; insn[Q16SLR,EXTEND] ="110101";
  insn[Q16SAR,MINOR0] =""; insn[Q16SAR,EXTEND] ="110111";
  insn[D32SLLV,MINOR0] ="000"; insn[D32SLLV,EXTEND] ="110110";
  insn[D32SLRV,MINOR0] ="001"; insn[D32SLRV,EXTEND] ="110110";
  insn[D32SARV,MINOR0] ="011"; insn[D32SARV,EXTEND] ="110110";
  insn[Q16SLLV,MINOR0] ="100"; insn[Q16SLLV,EXTEND] ="110110";
  insn[Q16SLRV,MINOR0] ="101"; insn[Q16SLRV,EXTEND] ="110110";
  insn[Q16SARV,MINOR0] ="111"; insn[Q16SARV,EXTEND] ="110110";
  insn[D32SARW,MINOR0] ="000"; insn[D32SARW,EXTEND] ="100111";

  insn[S32SFL,MINOR0] =""; insn[S32SFL,EXTEND] ="111101";
  insn[S32CPS,MINOR0] ="000"; insn[S32CPS,EXTEND] ="000111";
  insn[S32MAX,MINOR0] ="000"; insn[S32MAX,EXTEND] ="000011";
  insn[S32MIN,MINOR0] ="001"; insn[S32MIN,EXTEND] ="000011";
  insn[S32ALN,MINOR0] ="001"; insn[S32ALN,EXTEND] ="100111";
  insn[S32M2I,MINOR0] =""; insn[S32M2I,EXTEND] ="101110";
  insn[S32I2M,MINOR0] =""; insn[S32I2M,EXTEND] ="101111";
  insn[S32LDD,MINOR0] =""; insn[S32LDD,EXTEND] ="010000";
  insn[S32STD,MINOR0] =""; insn[S32STD,EXTEND] ="010001";
  insn[S32LDI,MINOR0] =""; insn[S32LDI,EXTEND] ="010100";
  insn[S32SDI,MINOR0] =""; insn[S32SDI,EXTEND] ="010101";
  insn[S32LDDV,MINOR0] =""; insn[S32LDDV,EXTEND] ="010010";
  insn[S32STDV,MINOR0] =""; insn[S32STDV,EXTEND] ="010011";
  insn[S32LDIV,MINOR0] =""; insn[S32LDIV,EXTEND] ="010110";
  insn[S32SDIV,MINOR0] =""; insn[S32SDIV,EXTEND] ="010111";

#MXU enhance
  insn[D16MULE,MINOR0] =""; insn[D16MULE,EXTEND] ="001001";
  insn[D16MACE,MINOR0] =""; insn[D16MACE,EXTEND] ="001111";
  insn[Q8MULSU,MINOR0] =""; insn[Q8MULSU,EXTEND] ="111000";
  insn[Q8MACSU,MINOR0] =""; insn[Q8MACSU,EXTEND] ="111010";
  insn[Q8MOVZ,MINOR0] ="000"; insn[Q8MOVZ,EXTEND] ="111001";
  insn[Q8MOVN,MINOR0] ="001"; insn[Q8MOVN,EXTEND] ="111001";
  insn[D16MOVZ,MINOR0] ="010"; insn[D16MOVZ,EXTEND] ="111001";
  insn[D16MOVN,MINOR0] ="011"; insn[D16MOVN,EXTEND] ="111001";
  insn[S32MOVZ,MINOR0] ="100"; insn[S32MOVZ,EXTEND] ="111001";
  insn[S32MOVN,MINOR0] ="101"; insn[S32MOVN,EXTEND] ="111001";
  insn[D32ACCM,MINOR0] =""; insn[D32ACCM,EXTEND] ="011001";
  insn[D32ASUM,MINOR0] =""; insn[D32ASUM,EXTEND] ="011001";
  insn[Q16ACCM,MINOR0] =""; insn[Q16ACCM,EXTEND] ="011011";
  insn[D16ASUM,MINOR0] =""; insn[D16ASUM,EXTEND] ="011011";
  insn[D8SUM,MINOR0] =""; insn[D8SUM,EXTEND] ="011100";
  insn[D8SUMC,MINOR0] =""; insn[D8SUMC,EXTEND] ="011100";
  insn[S32SLT,MINOR0] ="000"; insn[S32SLT,EXTEND] ="000110";
  insn[D16SLT,MINOR0] ="001"; insn[D16SLT,EXTEND] ="000110";
  insn[Q8SLTU,MINOR0] ="111"; insn[Q8SLTU,EXTEND] ="000011";
  insn[S32ALNI,MINOR0] ="010"; insn[S32ALNI,EXTEND] ="100111";
  insn[S32LUI,MINOR0] ="011"; insn[S32LUI,EXTEND] ="100111";
  insn[S32NOR,MINOR0] ="100"; insn[S32NOR,EXTEND] ="100111";
  insn[S32AND,MINOR0] ="101"; insn[S32AND,EXTEND] ="100111";
  insn[S32OR,MINOR0] ="110"; insn[S32OR,EXTEND] ="100111";
  insn[S32XOR,MINOR0] ="111"; insn[S32XOR,EXTEND] ="100111";
  insn[S32LDDR,MINOR0] =""; insn[S32LDDR,EXTEND] ="010000";
  insn[S32STDR,MINOR0] =""; insn[S32STDR,EXTEND] ="010001";
  insn[S32LDIR,MINOR0] =""; insn[S32LDIR,EXTEND] ="010100";
  insn[S32SDIR,MINOR0] =""; insn[S32SDIR,EXTEND] ="010101";
  insn[S32LDDVR,MINOR0] =""; insn[S32LDDVR,EXTEND] ="010010";
  insn[S32STDVR,MINOR0] =""; insn[S32STDVR,EXTEND] ="010011";
  insn[S32LDIVR,MINOR0] =""; insn[S32LDIVR,EXTEND] ="010110";
  insn[S32SDIVR,MINOR0] =""; insn[S32SDIVR,EXTEND] ="010111";
  insn[S8LDD,MINOR0] =""; insn[S8LDD,EXTEND] ="100010";
  insn[S8STD,MINOR0] =""; insn[S8STD,EXTEND] ="100011";
  insn[S8LDI,MINOR0] =""; insn[S8LDI,EXTEND] ="100100";
  insn[S8SDI,MINOR0] =""; insn[S8SDI,EXTEND] ="100101";
  insn[S16LDD,MINOR0] =""; insn[S16LDD,EXTEND] ="101010";
  insn[S16STD,MINOR0] =""; insn[S16STD,EXTEND] ="101011";
  insn[S16LDI,MINOR0] =""; insn[S16LDI,EXTEND] ="101100";
  insn[S16SDI,MINOR0] =""; insn[S16SDI,EXTEND] ="101101";
  insn[S32EXTR,MINOR0] =""; insn[S32EXTR,EXTEND] ="100110";
  insn[S32EXTRV,MINOR0] =""; insn[S32EXTRV,EXTEND] ="100110";
  insn[S32MUL,MINOR0] =""; insn[S32MUL,EXTEND] ="100110";
  insn[S32MULU,MINOR0] =""; insn[S32MULU,EXTEND] ="100110";
  insn[S32MADD,MINOR0] =""; insn[S32MADD,EXTEND] ="000000";
  insn[S32MADDU,MINOR0] =""; insn[S32MADDU,EXTEND] ="000001";
  insn[S32MSUB,MINOR0] =""; insn[S32MSUB,EXTEND] ="000100";
  insn[S32MSUBU,MINOR0] =""; insn[S32MSUBU,EXTEND] ="000101";
  insn[D32ADDC,MINOR0] =""; insn[D32ADDC,EXTEND] ="011000";
  insn[Q16SCOP,MINOR0] =""; insn[Q16SCOP,EXTEND] ="111011";
  insn[LXB,MINOR0] =""; insn[LXB,EXTEND] ="101000";
  insn[LXH,MINOR0] =""; insn[LXH,EXTEND] ="101000";
  insn[LXW,MINOR0] =""; insn[LXW,EXTEND] ="101000";
  insn[LXBU,MINOR0] =""; insn[LXBU,EXTEND] ="101000";
  insn[LXHU,MINOR0] =""; insn[LXHU,EXTEND] ="101000";

#&lt;------Specific binary code of S32SFL
  SFL_PTN[PTN0]="00"; SFL_PTN[PTN1]="01";  SFL_PTN[PTN2]="10"; SFL_PTN[PTN3]="11";
  SFL_PTN[0]="00"; SFL_PTN[1]="01"; SFL_PTN[2]="10"; SFL_PTN[3]="11";
#MXU enhance
  BYTE_PTN[PTN0]="000"; BYTE_PTN[PTN1]="001"; BYTE_PTN[PTN2]="010"; BYTE_PTN[PTN3]="011"; 
  BYTE_PTN[PTN4]="100"; BYTE_PTN[PTN5]="101"; BYTE_PTN[PTN6]="110"; BYTE_PTN[PTN7]="111"; 
  BYTE_PTN[0]="000"; BYTE_PTN[1]="001"; BYTE_PTN[2]="010"; BYTE_PTN[3]="011"; 
  BYTE_PTN[4]="100"; BYTE_PTN[5]="101"; BYTE_PTN[6]="110"; BYTE_PTN[7]="111"; 
 }

############################################################################################
#Real assemble process begins from here
############################################################################################
# Preprocess each record
  (NF != 0) {sub(/^[ \t]+/, "", $0); MXINSN_OK=0; cur_line=$0;}
  ( match(toupper($0), "^[A-Z_][0-9A-Z_]*[ \t]*:[ \t]*[0-9A-Z_]+") == 1) { \
  as_label=substr($0, 1, RLENGTH); print as_label; $0=substr($0,RLENGTH+1) }

#&lt;---------------------------------------------------------------------------LX
  ( match(toupper($1),"LX") == 1 ) { sub(/\#.*$/, "", $0); sub(/[ \t]+$/, "", $0);
  $0 = toupper($0); tmp=$0; gsub(/[ \t]+/, "", tmp);
  if (match($1, "LX[BH][U]?")==1) {
  if ($(NF-3) ~/[A-Z]/ ) { sub("[\$]","", $(NF-3)); $(NF-3)="$"grf[$(NF-3)];}
  if ($(NF-2) ~/[A-Z]/ ) { sub("[\$]","", $(NF-2)); $(NF-2)="$"grf[$(NF-2)];}
  if ($(NF-1) ~/[A-Z]/ ) { sub("[\$]","", $(NF-1)); $(NF-1)="$"grf[$(NF-1)];}
  x_num=split($0,x_a); x_a[x_num-3]=$(NF-3); x_a[x_num-2]=$(NF-2); x_a[x_num-1]=$(NF-1); tmp=$1; 
  for(i=2;i&lt;=x_num-1;i=i+1) {tmp=tmp""x_a[i]","}; tmp=tmp""x_a[x_num];
  assert(match(tmp, "LX[BH][U]?[\$]([12]?[0-9]|3[01]),[\$]([12]?[0-9]|3[01]),\
[\$]([12]?[0-9]|3[01]),([0-2]|0X[0-2])$")==1, "syntax err");
  MXINSN_OK=1;
  rd=substr($(NF-3),2); grfd_num = bits2str(strtonum(rd), 5);
  rb=substr($(NF-2),2); grfb_num = bits2str(strtonum(rb), 5);
  rc=substr($(NF-1),2); grfc_num = bits2str(strtonum(rc), 5);
  strd_num = bits2str(strtonum($NF), 2);
  if ($1 ~/LXH/) size="01";
  else size="00";
  if ($1 ~/U/) unsign="1";
  else unsign="0";
  printf ".word\t0b%s%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, grfb_num, grfc_num, grfd_num, strd_num, \
  unsign, size, insn[$1,EXTEND], $0; 
  next
  }
  if (match($1, "LXW")==1) {
  if ($(NF-3) ~/[A-Z]/ ) { sub("[\$]","", $(NF-3)); $(NF-3)="$"grf[$(NF-3)];}
  if ($(NF-2) ~/[A-Z]/ ) { sub("[\$]","", $(NF-2)); $(NF-2)="$"grf[$(NF-2)];}
  if ($(NF-1) ~/[A-Z]/ ) { sub("[\$]","", $(NF-1)); $(NF-1)="$"grf[$(NF-1)];}
  x_num=split($0,x_a); x_a[x_num-3]=$(NF-3); x_a[x_num-2]=$(NF-2); x_a[x_num-1]=$(NF-1); tmp=$1; 
  for(i=2;i&lt;=x_num-1;i=i+1) {tmp=tmp""x_a[i]","}; tmp=tmp""x_a[x_num];
  assert(match(tmp, "LXW[\$]([12]?[0-9]|3[01]),[\$]([12]?[0-9]|3[01]),\
[\$]([12]?[0-9]|3[01]),([0-2]|0X[0-2])$")==1, "syntax err");
  MXINSN_OK=1;
  rd=substr($(NF-3),2); grfd_num = bits2str(strtonum(rd), 5);
  rb=substr($(NF-2),2); grfb_num = bits2str(strtonum(rb), 5);
  rc=substr($(NF-1),2); grfc_num = bits2str(strtonum(rc), 5);
  strd_num = bits2str(strtonum($NF), 2);
  printf ".word\t0b%s%s%s%s%s011%s\t\#%s\n", SPECIAL2, grfb_num, grfc_num, grfd_num, strd_num, \
  insn[$1,EXTEND], $0; 
  next
  }
$0 = cur_line;
}

#&lt;---------------------------------------------------------------------------Q8/D8
  ( match(toupper($1),"[QD]8") == 1 ) { sub(/\#.*$/, "", $0); sub(/[ \t]+$/, "", $0);
  $0 = toupper($0); tmp=$0; gsub(/[ \t]+/, "", tmp);

  q8_eptn2="00"; q8_optn2="00";

  if (match($1, "Q8MUL(|SU)")==1) {
  assert(match(tmp, "Q8MUL(|SU)XR([0-9]|1[0-5]),XR([0-9]|1[0-5]),XR([0-9]|1[0-5]),\
XR([0-9]|1[0-5])$")==1, "syntax err");
  MXINSN_OK=1;
  if ($1 ~/SU/) q8_optn2="10";
  Q8_XRD=xrf[$5];
  printf ".word\t0b%s%s%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, q8_eptn2, q8_optn2, \
  insn[$1,MINOR0], Q8_XRD, xrf[$4], xrf[$3], xrf[$2], insn[$1,EXTEND], $0;
  next
  }
  if (match($1, "Q8MAC(|SU)")==1) {
  assert(match(tmp, "Q8MAC(|SU)XR([0-9]|1[0-5]),XR([0-9]|1[0-5]),XR([0-9]|1[0-5]),\
XR([0-9]|1[0-5]),([AS][AS]|[0-3])$")==1, "syntax err");
  MXINSN_OK=1;
  q8_eptn2 = MAC_AS[$NF];
  if ($1 ~/SU/) q8_optn2="10";
  Q8_XRD=xrf[$5];
  printf ".word\t0b%s%s%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, q8_eptn2, q8_optn2, \
  insn[$1,MINOR0], Q8_XRD, xrf[$4], xrf[$3], xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
  if (match($1, "Q8MADL")==1) {
  assert(match(tmp, "Q8MADLXR([0-9]|1[0-5]),XR([0-9]|1[0-5]),XR([0-9]|1[0-5]),\
XR([0-9]|1[0-5]),([AS][AS]|[0-3])$")==1, "syntax err");
  MXINSN_OK=1;
  q8_eptn2 = MAC_AS[$NF];
  Q8_XRD=xrf[$5];
  printf ".word\t0b%s%s%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, q8_eptn2, q8_optn2, \
  insn[$1,MINOR0], Q8_XRD, xrf[$4], xrf[$3], xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
  if (match($1, "Q8SAD")==1) {
  assert(match(tmp, "Q8SADXR([0-9]|1[0-5]),XR([0-9]|1[0-5]),XR([0-9]|1[0-5]),\
XR([0-9]|1[0-5])$")==1, "syntax err");
  MXINSN_OK=1;
  Q8_XRD=xrf[$5];
  printf ".word\t0b%s%s%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, q8_eptn2, q8_optn2, \
  insn[$1,MINOR0], Q8_XRD, xrf[$4], xrf[$3], xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
  if (match($1, "Q8A(DD|CC)E")==1) {
  assert(match(tmp, "Q8A(DD|CC)EXR([0-9]|1[0-5]),XR([0-9]|1[0-5]),XR([0-9]|1[0-5]),\
XR([0-9]|1[0-5]),([AS][AS]|[0-3])$")==1, "syntax err");
  MXINSN_OK=1;
  q8_eptn2 = MAC_AS[$NF];
  Q8_XRD=xrf[$5];
  printf ".word\t0b%s%s%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, q8_eptn2, q8_optn2, \
  insn[$1,MINOR0], Q8_XRD, xrf[$4], xrf[$3], xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
  if (match($1, "Q8ABD")==1) {
  assert(match(tmp, "Q8ABDXR([0-9]|1[0-5]),XR([0-9]|1[0-5]),XR([0-9]|1[0-5])$"\
)==1, "syntax err");
  MXINSN_OK=1;
  q8_optn2="000";
  Q8_XRD="";
  printf ".word\t0b%s%s%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, q8_eptn2, q8_optn2, \
  insn[$1,MINOR0], Q8_XRD, xrf[$4], xrf[$3], xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
  if (match($1, "Q8AVG[R]?")==1) {
  assert(match(tmp, "Q8AVG[R]?XR([0-9]|1[0-5]),XR([0-9]|1[0-5]),XR([0-9]|1[0-5])$"\
)==1, "syntax err");
  MXINSN_OK=1;
  q8_optn2="000";
  Q8_XRD="";
  printf ".word\t0b%s%s%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, q8_eptn2, q8_optn2, \
  insn[$1,MINOR0], Q8_XRD, xrf[$4], xrf[$3], xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
  if (match($1, "Q8ADD")==1) {
  assert(match(tmp, "Q8ADDXR([0-9]|1[0-5]),XR([0-9]|1[0-5]),XR([0-9]|1[0-5]),\
([AS][AS]|[0-3])$")==1, "syntax err");
  MXINSN_OK=1;
  q8_eptn2 = MAC_AS[$NF];
  q8_optn2="000";
  Q8_XRD="";
  printf ".word\t0b%s%s%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, q8_eptn2, q8_optn2, \
  insn[$1,MINOR0], Q8_XRD, xrf[$4], xrf[$3], xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
  if (match($1, "Q8M(AX|IN)")==1) {
  assert(match(tmp, "Q8M(AX|IN)XR([0-9]|1[0-5]),XR([0-9]|1[0-5]),XR([0-9]|1[0-5])$"\
)==1, "syntax err");
  MXINSN_OK=1;
  q8_optn2="000";
  Q8_XRD="";
  printf ".word\t0b%s%s%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, q8_eptn2, q8_optn2, \
  insn[$1,MINOR0], Q8_XRD, xrf[$4], xrf[$3], xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
  if (match($1, "Q8SLT[U]?")==1) {
  assert(match(tmp, "Q8SLT[U]?XR([0-9]|1[0-5]),XR([0-9]|1[0-5]),XR([0-9]|1[0-5])$"\
)==1, "syntax err");
  MXINSN_OK=1;
  q8_optn2="000";
  Q8_XRD="";
  printf ".word\t0b%s%s%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, q8_eptn2, q8_optn2, \
  insn[$1,MINOR0], Q8_XRD, xrf[$4], xrf[$3], xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
  if (match($1, "Q8MOV[ZN]")==1) {
  assert(match(tmp, "Q8MOV[ZN]XR([0-9]|1[0-5]),XR([0-9]|1[0-5]),XR([0-9]|1[0-5])$"\
)==1, "syntax err");
  MXINSN_OK=1;
  q8_optn2="000";
  Q8_XRD="";
  printf ".word\t0b%s%s%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, q8_eptn2, q8_optn2, \
  insn[$1,MINOR0], Q8_XRD, xrf[$4], xrf[$3], xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
  if (match($1, "D8SUM[C]?")==1) {
  assert(match(tmp, "D8SUM[C]?XR([0-9]|1[0-5]),XR([0-9]|1[0-5]),XR([0-9]|1[0-5])$"\
)==1, "syntax err");
  MXINSN_OK=1;
  if ($1 ~/C/) q8_optn2="10";
  else q8_optn2="01";
  Q8_XRD="0000";
  printf ".word\t0b%s%s%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, q8_eptn2, q8_optn2, \
  insn[$1,MINOR0], Q8_XRD, xrf[$4], xrf[$3], xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
$0 = cur_line;
}
#&lt;---------------------------------------------------------------------------S8
  ( match(toupper($1),"S8") == 1 ) { sub(/\#.*$/, "", $0); sub(/[ \t]+$/, "", $0);
  $0 = toupper($0); tmp=$0; gsub(/[ \t]+/, "", tmp);
  if (match($1, "S8(LD[DI]|S(TD|DI))")==1) {
  if ($(NF-2) ~/[A-Z]/ ) { sub("[\$]","", $(NF-2)); $(NF-2)="$"grf[$(NF-2)];
  x_num=split(tmp,x_a); x_a[x_num-2]=$(NF-2); tmp=""; 
  for(i=1;i&lt;=x_num-1;i=i+1) {tmp=tmp""x_a[i]","}; tmp=tmp""x_a[x_num]; }
  assert(match(tmp, "S8(LD[DI]|S(TD|DI))XR([0-9]|1[0-5]),[\$]([12]?[0-9]|3[01]),\
[\-]?([0-9]+|0X[0-9A-F]+),(PTN[0-7]|[0-7])$")==1, "syntax err");
  MXINSN_OK=1;
  rb=substr($(NF-2),2); grfb_num = bits2str(strtonum(rb), 5);
  if ($(NF-1) ~/-/) {s8_pos=substr($(NF-1), 2); num_s8 = 0 - strtonum(s8_pos); }
  else num_s8 = strtonum($(NF-1));
  addr_off = bits2str(num_s8, 8); 
  s8_eptn3 = BYTE_PTN[$NF];
  printf ".word\t0b%s%s%s%s%s%s\t\#%s\n", SPECIAL2, grfb_num, s8_eptn3, addr_off, \
xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
$0 = cur_line;
}
#&lt;---------------------------------------------------------------------------Q16/D16/S16
  ( match(toupper($1),"[QDS]16") == 1 ) { sub(/\#.*$/, "", $0); sub(/[ \t]+$/, "", $0);
  $0 = toupper($0); tmp=$0; gsub(/[ \t]+/, "", tmp);

  q16_eptn2="00"; q16_optn2="00"; 

  if (match($1, "D16MUL[EF]?")==1) {
  if ($1 ~/F/) {
  assert(match(tmp, "D16MULFXR([0-9]|1[0-5]),XR([0-9]|1[0-5]),XR([0-9]|1[0-5]),\
([WLHX]W|[0-3])$")==1, "syntax err");
  MXINSN_OK=1;
  q16_optn2 = MUL_PTN[$NF];
  Q16_XRD="0000";
  printf ".word\t0b%s%s%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, q16_eptn2, q16_optn2, \
  insn[$1,MINOR0], Q16_XRD, xrf[$4], xrf[$3], xrf[$2], insn[$1,EXTEND], $0; 
  next
  } else {
  assert(match(tmp, "D16MUL[E]?XR([0-9]|1[0-5]),XR([0-9]|1[0-5]),XR([0-9]|1[0-5]),\
XR([0-9]|1[0-5]),([WLHX]W|[0-3])$")==1, "syntax err");
  MXINSN_OK=1;
  if ($1 ~/E/) q16_eptn2="01";
  q16_optn2 = MUL_PTN[$NF];
  Q16_XRD=xrf[$5];
  printf ".word\t0b%s%s%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, q16_eptn2, q16_optn2, \
  insn[$1,MINOR0], Q16_XRD, xrf[$4], xrf[$3], xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
  }
  if (match($1, "D16MAC[EF]?")==1) {
  assert(match(tmp, "D16MAC[EF]?XR([0-9]|1[0-5]),XR([0-9]|1[0-5]),XR([0-9]|1[0-5]),\
XR([0-9]|1[0-5]),([AS][AS]|[0-3]),([WLHX]W|[0-3])$")==1, "syntax err");
  MXINSN_OK=1;
  q16_eptn2 = MAC_AS[$(NF-1)];
  q16_optn2 = MUL_PTN[$NF];
  Q16_XRD=xrf[$5];
  printf ".word\t0b%s%s%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, q16_eptn2, q16_optn2, \
  insn[$1,MINOR0], Q16_XRD, xrf[$4], xrf[$3], xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
  if (match($1, "D16MADL")==1) {
  assert(match(tmp, "D16MADLXR([0-9]|1[0-5]),XR([0-9]|1[0-5]),XR([0-9]|1[0-5]),\
XR([0-9]|1[0-5]),([AS][AS]|[0-3]),([WLHX]W|[0-3])$")==1, "syntax err");
  MXINSN_OK=1;
  q16_eptn2 = MAC_AS[$(NF-1)];
  q16_optn2 = MUL_PTN[$NF];
  Q16_XRD=xrf[$5];
  printf ".word\t0b%s%s%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, q16_eptn2, q16_optn2, \
  insn[$1,MINOR0], Q16_XRD, xrf[$4], xrf[$3], xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
  if (match($1, "S16MAD")==1) {
  assert(match(tmp, "S16MADXR([0-9]|1[0-5]),XR([0-9]|1[0-5]),XR([0-9]|1[0-5]),\
XR([0-9]|1[0-5]),[AS01],(PTN[0-3]|[0-3])$")==1, "syntax err");
  MXINSN_OK=1;
  if ($(NF-1) ~/[0A]/) q16_eptn2 = "00";
  else q16_eptn2 = "01";
  q16_optn2 = SFL_PTN[$NF];
  Q16_XRD=xrf[$5];
  printf ".word\t0b%s%s%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, q16_eptn2, q16_optn2, \
  insn[$1,MINOR0], Q16_XRD, xrf[$4], xrf[$3], xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
  if (match($1, "S16(LD[DI]|S(TD|DI))")==1) {
  if ($(NF-2) ~/[A-Z]/ ) { sub("[\$]","", $(NF-2)); $(NF-2)="$"grf[$(NF-2)];
  x_num=split(tmp,x_a); x_a[x_num-2]=$(NF-2); tmp=""; 
  for(i=1;i&lt;=x_num-1;i=i+1) {tmp=tmp""x_a[i]","}; tmp=tmp""x_a[x_num]; }
  assert(match(tmp, "S16(LD[DI]|S(TD|DI))XR([0-9]|1[0-5]),[\$]([12]?[0-9]|3[01]),\
[\-]?([0-9]+|0X[0-9A-F]+),(PTN[0-3]|[0-3])$")==1, "syntax err");
  MXINSN_OK=1;
  rb=substr($(NF-2),2); grfb_num = bits2str(strtonum(rb), 5);
  if ($(NF-1) ~/-/) {s10_pos=substr($(NF-1), 2); num_s10 = 0 - strtonum(s10_pos); }
  else num_s10 = strtonum($(NF-1));
  S10 = bits2str(num_s10, 10); addr_off=substr(S10,1,9);
  s16_eptn2 = SFL_PTN[$NF];
  printf ".word\t0b%s%s%s%s%s%s\t\#%s\n", SPECIAL2, grfb_num, s16_eptn2, addr_off, \
xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
  if (match($1, "Q16SCOP")==1) {
  assert(match(tmp, "Q16SCOPXR([0-9]|1[0-5]),XR([0-9]|1[0-5]),XR([0-9]|1[0-5]),\
XR([0-9]|1[0-5])$")==1, "syntax err");
  MXINSN_OK=1;
  q16_eptn2 = "00";
  q16_optn2 = "00";
  Q16_XRD=xrf[$5];
  printf ".word\t0b%s%s%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, q16_eptn2, q16_optn2, \
  insn[$1,MINOR0], Q16_XRD, xrf[$4], xrf[$3], xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
  if (match($1, "Q16ADD")==1) {
  assert(match(tmp, "Q16ADDXR([0-9]|1[0-5]),XR([0-9]|1[0-5]),XR([0-9]|1[0-5]),\
XR([0-9]|1[0-5]),([AS][AS]|[0-3]),([WLHX]W|[0-3])$")==1, "syntax err");
  MXINSN_OK=1;
  q16_eptn2 = MAC_AS[$(NF-1)];
  q16_optn2 = MUL_PTN[$NF];
  Q16_XRD=xrf[$5];
  printf ".word\t0b%s%s%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, q16_eptn2, q16_optn2, \
  insn[$1,MINOR0], Q16_XRD, xrf[$4], xrf[$3], xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
  if (match($1, "Q16ACC[M]?")==1) {
  assert(match(tmp, "Q16ACC[M]?XR([0-9]|1[0-5]),XR([0-9]|1[0-5]),XR([0-9]|1[0-5]),\
XR([0-9]|1[0-5]),([AS][AS]|[0-3])$")==1, "syntax err");
  MXINSN_OK=1;
  q16_eptn2 = MAC_AS[$NF];
  if ($1 ~/M/) q16_optn2 = "01";
  Q16_XRD=xrf[$5];
  printf ".word\t0b%s%s%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, q16_eptn2, q16_optn2, \
  insn[$1,MINOR0], Q16_XRD, xrf[$4], xrf[$3], xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
  if (match($1, "D16ASUM")==1) {
  assert(match(tmp, "D16ASUMXR([0-9]|1[0-5]),XR([0-9]|1[0-5]),XR([0-9]|1[0-5]),\
XR([0-9]|1[0-5]),([AS][AS]|[0-3])$")==1, "syntax err");
  MXINSN_OK=1;
  q16_eptn2 = MAC_AS[$NF];
  q16_optn2 = "10";
  Q16_XRD=xrf[$5];
  printf ".word\t0b%s%s%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, q16_eptn2, q16_optn2, \
  insn[$1,MINOR0], Q16_XRD, xrf[$4], xrf[$3], xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
  if (match($1, "D16CPS")==1) {
  assert(match(tmp, "D16CPSXR([0-9]|1[0-5]),XR([0-9]|1[0-5]),XR([0-9]|1[0-5])$")\
==1, "syntax err");
  MXINSN_OK=1;
  q16_optn2 = "000";
  Q16_XRD="";
  printf ".word\t0b%s%s%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, q16_eptn2, q16_optn2, \
  insn[$1,MINOR0], Q16_XRD, xrf[$4], xrf[$3], xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
  if (match($1, "Q16SAT")==1) {
  assert(match(tmp, "Q16SATXR([0-9]|1[0-5]),XR([0-9]|1[0-5]),XR([0-9]|1[0-5])$")\
==1, "syntax err");
  MXINSN_OK=1;
  q16_optn2 = "000";
  Q16_XRD="";
  printf ".word\t0b%s%s%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, q16_eptn2, q16_optn2, \
  insn[$1,MINOR0], Q16_XRD, xrf[$4], xrf[$3], xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
  if (match($1, "D16AVG[R]?")==1) {
  assert(match(tmp, "D16AVG[R]?XR([0-9]|1[0-5]),XR([0-9]|1[0-5]),XR([0-9]|1[0-5])$"\
)==1, "syntax err");
  MXINSN_OK=1;
  q16_optn2 = "000";
  Q16_XRD="";
  printf ".word\t0b%s%s%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, q16_eptn2, q16_optn2, \
  insn[$1,MINOR0], Q16_XRD, xrf[$4], xrf[$3], xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
  if (match($1, "D16M(AX|IN)")==1) {
  assert(match(tmp, "D16M(AX|IN)XR([0-9]|1[0-5]),XR([0-9]|1[0-5]),XR([0-9]|1[0-5])$"\
)==1, "syntax err");
  MXINSN_OK=1;
  q16_optn2 = "000";
  Q16_XRD="";
  printf ".word\t0b%s%s%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, q16_eptn2, q16_optn2, \
  insn[$1,MINOR0], Q16_XRD, xrf[$4], xrf[$3], xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
  if (match($1, "D16MOV[ZN]")==1) {
  assert(match(tmp, "D16MOV[ZN]XR([0-9]|1[0-5]),XR([0-9]|1[0-5]),XR([0-9]|1[0-5])$"\
)==1, "syntax err");
  MXINSN_OK=1;
  q16_optn2 = "000";
  Q16_XRD="";
  printf ".word\t0b%s%s%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, q16_eptn2, q16_optn2, \
  insn[$1,MINOR0], Q16_XRD, xrf[$4], xrf[$3], xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
  if (match($1, "D16SLT")==1) {
  assert(match(tmp, "D16SLTXR([0-9]|1[0-5]),XR([0-9]|1[0-5]),XR([0-9]|1[0-5])$"\
)==1, "syntax err");
  MXINSN_OK=1;
  q16_optn2 = "000";
  Q16_XRD="";
  printf ".word\t0b%s%s%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, q16_eptn2, q16_optn2, \
  insn[$1,MINOR0], Q16_XRD, xrf[$4], xrf[$3], xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
  if (match($1, "Q16S(LL|(LR|AR))[V]?")==1) {
  if ($1 ~/V/) {
  if ($NF ~/[A-Z]/) {sub("[\$]","", $NF); $NF="$"grf[$NF]; x_num=split(tmp,x_a); tmp=""; 
  for(i=1;i&lt;x_num;i=i+1) {tmp=tmp""x_a[i]","}; tmp=tmp""$NF;};
  assert(match(tmp, "Q16S(LL|(LR|AR))VXR([0-9]|1[0-5]),XR([0-9]|1[0-5]),\
[\$]([12]?[0-9]|3[01])$")==1, "syntax err");
  MXINSN_OK=1;
  rb=substr($(NF),2); grf_num = bits2str(strtonum(rb), 5);
  printf ".word\t0b%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, grf_num, insn[$1,MINOR0], \
xrf[$3], xrf[$2], "0000", insn[$1,EXTEND], $0; 
  next
  } else {
  assert(match(tmp, "Q16S(LL|(LR|AR))XR([0-9]|1[0-5]),XR([0-9]|1[0-5]),\
XR([0-9]|1[0-5]),XR([0-9]|1[0-5]),(([0-9]|1[0-5])|0X[0-9A-F])$")==1, "syntax err");
  MXINSN_OK=1;
  sft_num = bits2str(strtonum($NF), 4);
  Q16_XRD=xrf[$5];
  printf ".word\t0b%s%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, sft_num, insn[$1,MINOR0], \
Q16_XRD, xrf[$4], xrf[$3], xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
  }
$0 = cur_line;
}

#&lt;---------------------------------------------------------------------------D32/S32
  ( match(toupper($1),"[DS]32") == 1 ) { sub(/\#.*$/, "", $0); sub(/[ \t]+$/, "", $0);
  $0 = toupper($0); tmp=$0; gsub(/[ \t]+/, "", tmp);

  q32_eptn2="00"; q32_optn2="00"; 

  if (match($1, "S32SFL")==1) {
  assert(match(tmp, "S32SFLXR([0-9]|1[0-5]),XR([0-9]|1[0-5]),XR([0-9]|1[0-5]),\
XR([0-9]|1[0-5]),(PTN[0-3]|[01][01])$")==1, "syntax err");
  MXINSN_OK=1;
  if ($NF ~/PTN/) q32_eptn2 = SFL_PTN[$NF];
  else q32_eptn2 = $NF;
  Q32_XRD=xrf[$5];
  printf ".word\t0b%s%s%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, q32_eptn2, q32_optn2, \
  insn[$1,MINOR0], Q32_XRD, xrf[$4], xrf[$3], xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
  if (match($1, "D32ADDC")==1) {
  assert(match(tmp, "D32ADDCXR([0-9]|1[0-5]),XR([0-9]|1[0-5]),XR([0-9]|1[0-5]),\
XR([0-9]|1[0-5])$")==1, "syntax err");
  MXINSN_OK=1;
  q32_optn2 = "01";
  q32_eptn2 = "00";
  Q32_XRD=xrf[$5];
  printf ".word\t0b%s%s%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, q32_eptn2, q32_optn2, \
  insn[$1,MINOR0], Q32_XRD, xrf[$4], xrf[$3], xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
  if (match($1, "D32A(DD|CC[M]?)")==1) {
  assert(match(tmp, "D32A(DD|CC[M]?)XR([0-9]|1[0-5]),XR([0-9]|1[0-5]),XR([0-9]|1[0-5]),\
XR([0-9]|1[0-5]),([AS][AS]|[0-3])$")==1, "syntax err");
  MXINSN_OK=1;
  if ($1 ~/M/) q32_optn2 = "01";
  q32_eptn2 = MAC_AS[$NF];
  Q32_XRD=xrf[$5];
  printf ".word\t0b%s%s%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, q32_eptn2, q32_optn2, \
  insn[$1,MINOR0], Q32_XRD, xrf[$4], xrf[$3], xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
  if (match($1, "D32ASUM")==1) {
  assert(match(tmp, "D32ASUMXR([0-9]|1[0-5]),XR([0-9]|1[0-5]),XR([0-9]|1[0-5]),\
XR([0-9]|1[0-5]),([AS][AS]|[0-3])$")==1, "syntax err");
  MXINSN_OK=1;
  q32_optn2 = "10";
  q32_eptn2 = MAC_AS[$NF];
  Q32_XRD=xrf[$5];
  printf ".word\t0b%s%s%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, q32_eptn2, q32_optn2, \
  insn[$1,MINOR0], Q32_XRD, xrf[$4], xrf[$3], xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
  if (match($1, "S32CPS")==1) {
  assert(match(tmp, "S32CPSXR([0-9]|1[0-5]),XR([0-9]|1[0-5]),XR([0-9]|1[0-5])$")\
==1, "syntax err");
  MXINSN_OK=1;
  q32_optn2 = "000";
  Q32_XRD="";
  printf ".word\t0b%s%s%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, q32_eptn2, q32_optn2, \
  insn[$1,MINOR0], Q32_XRD, xrf[$4], xrf[$3], xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
  if (match($1, "S32MOV[ZN]")==1) {
  assert(match(tmp, "S32MOV[ZN]XR([0-9]|1[0-5]),XR([0-9]|1[0-5]),XR([0-9]|1[0-5])$")\
==1, "syntax err");
  MXINSN_OK=1;
  q32_optn2 = "000";
  Q32_XRD="";
  printf ".word\t0b%s%s%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, q32_eptn2, q32_optn2, \
  insn[$1,MINOR0], Q32_XRD, xrf[$4], xrf[$3], xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
  if (match($1, "S32SLT")==1) {
  assert(match(tmp, "S32SLTXR([0-9]|1[0-5]),XR([0-9]|1[0-5]),XR([0-9]|1[0-5])$")\
==1, "syntax err");
  MXINSN_OK=1;
  q32_optn2 = "000";
  Q32_XRD="";
  printf ".word\t0b%s%s%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, q32_eptn2, q32_optn2, \
  insn[$1,MINOR0], Q32_XRD, xrf[$4], xrf[$3], xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
  if (match($1, "S32M(AX|IN)")==1) {
  assert(match(tmp, "S32M(AX|IN)XR([0-9]|1[0-5]),XR([0-9]|1[0-5]),XR([0-9]|1[0-5])$"\
)==1, "syntax err");
  MXINSN_OK=1;
  q32_optn2 = "000";
  Q32_XRD="";
  printf ".word\t0b%s%s%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, q32_eptn2, q32_optn2, \
  insn[$1,MINOR0], Q32_XRD, xrf[$4], xrf[$3], xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
  if (match($1, "D32SL[LR][V]?")==1) {
  if ($1 ~/V/) {
  if ($NF ~/[A-Z]/) {sub("[\$]","", $NF); $NF="$"grf[$NF]; x_num=split(tmp,x_a); tmp=""; 
  for(i=1;i&lt;x_num;i=i+1) {tmp=tmp""x_a[i]","}; tmp=tmp""$NF;};
  assert(match(tmp, "D32SL[LR]VXR([0-9]|1[0-5]),XR([0-9]|1[0-5]),\
[\$]([12]?[0-9]|3[01])$")==1, "syntax err");
  MXINSN_OK=1;
  rb=substr($(NF),2); grf_num = bits2str(strtonum(rb), 5);
  printf ".word\t0b%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, grf_num, insn[$1,MINOR0], \
xrf[$3], xrf[$2], "0000", insn[$1,EXTEND], $0; 
  next
  } else {
  assert(match(tmp, "D32SL[LR]XR([0-9]|1[0-5]),XR([0-9]|1[0-5]),XR([0-9]|1[0-5]),\
XR([0-9]|1[0-5]),(([0-9]|1[0-5])|0X[0-9A-F])$")==1, "syntax err");
  MXINSN_OK=1;
  sft_num = bits2str(strtonum($NF), 4);
  Q32_XRD=xrf[$5];
  printf ".word\t0b%s%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, sft_num, insn[$1,MINOR0]\
, Q32_XRD, xrf[$4], xrf[$3], xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
  }
  if (match($1, "D32SAR[LWV]?")==1) {
  sc=split($1, a, ""); 
  if (a[sc]=="V") {
  if ($NF ~/[A-Z]/) {sub("[\$]","", $NF); $NF="$"grf[$NF]; x_num=split(tmp,x_a); tmp=""; 
  for(i=1;i&lt;x_num;i=i+1) {tmp=tmp""x_a[i]","}; tmp=tmp""$NF;};
  assert(match(tmp, "D32SARVXR([0-9]|1[0-5]),XR([0-9]|1[0-5]),\
[\$]([12]?[0-9]|3[01])$")==1, "syntax err");
  MXINSN_OK=1;
  rb=substr($(NF),2); grf_num = bits2str(strtonum(rb), 5);
  printf ".word\t0b%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, grf_num, insn[$1,MINOR0], \
xrf[$3], xrf[$2], "0000", insn[$1,EXTEND], $0; 
  next
  } else {
  if (a[sc]=="W") {
  if ($NF ~/[A-Z]/) {sub("[\$]","", $NF); $NF="$"grf[$NF]; x_num=split(tmp,x_a); tmp=""; 
  for(i=1;i&lt;x_num;i=i+1) {tmp=tmp""x_a[i]","}; tmp=tmp""$NF;};
  assert(match(tmp, "D32SARWXR([0-9]|1[0-5]),XR([0-9]|1[0-5]),XR([0-9]|1[0-5]),\
[\$]([12]?[0-9]|3[01])$")==1, "syntax err");
  MXINSN_OK=1;
  rb=substr($(NF),2); grf_num = bits2str(strtonum(rb), 5);
  printf ".word\t0b%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, grf_num, insn[$1,MINOR0], \
xrf[$4], xrf[$3], xrf[$2], insn[$1,EXTEND], $0; 
  next
  } else {
  if (a[sc]=="L") {
  assert(match(tmp, "D32SARLXR([0-9]|1[0-5]),XR([0-9]|1[0-5]),XR([0-9]|1[0-5]),\
(([0-9]|1[0-5])|0X[0-9A-F])$")==1, "syntax err");
  MXINSN_OK=1;
  sft_num = bits2str(strtonum($NF), 4);
  Q32_XRD="0000";
  printf ".word\t0b%s%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, sft_num, insn[$1,MINOR0], \
Q32_XRD, xrf[$4], xrf[$3], xrf[$2], insn[$1,EXTEND], $0; 
  next
  } else {
  assert(match(tmp, "D32SARXR([0-9]|1[0-5]),XR([0-9]|1[0-5]),XR([0-9]|1[0-5]),\
XR([0-9]|1[0-5]),(([0-9]|1[0-5])|0X[0-9A-F])$")==1, "syntax err");
  MXINSN_OK=1;
  sft_num = bits2str(strtonum($NF), 4);
  Q32_XRD=xrf[$5];
  printf ".word\t0b%s%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, sft_num, insn[$1,MINOR0], \
Q32_XRD, xrf[$4], xrf[$3], xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
  }
  }
  }
  if (match($1, "S32ALNI")==1) {
  assert(match(tmp, "S32ALNIXR([0-9]|1[0-5]),XR([0-9]|1[0-5]),XR([0-9]|1[0-5]),\
(PTN[0-4]|[0-4])$")==1, "syntax err");
  MXINSN_OK=1;
  alni_ptn=BYTE_PTN[$NF];
  printf ".word\t0b%s%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, alni_ptn, "00", insn[$1,MINOR0], \
xrf[$4], xrf[$3], xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
  if (match($1, "S32ALN")==1) {
  if ($NF ~/[A-Z]/) {sub("[\$]","", $NF); $NF="$"grf[$NF]; x_num=split(tmp,x_a); tmp=""; 
  for(i=1;i&lt;x_num;i=i+1) {tmp=tmp""x_a[i]","}; tmp=tmp""$NF;};
  assert(match(tmp, "S32ALNXR([0-9]|1[0-5]),XR([0-9]|1[0-5]),XR([0-9]|1[0-5]),\
[\$]([12]?[0-9]|3[01])$")==1, "syntax err");
  MXINSN_OK=1;
  rb=substr($(NF),2); grf_num = bits2str(strtonum(rb), 5);
  printf ".word\t0b%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, grf_num, insn[$1,MINOR0], \
xrf[$4], xrf[$3], xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
  if (match($1, "S32LUI")==1) {
  assert(match(tmp, "S32LUIXR([0-9]|1[0-5]),[\-]?([0-9]+|0X[0-9A-F]+),\
(PTN[0-7]|[0-7])$")==1, "syntax err");
  MXINSN_OK=1;
  if ($(NF-1) ~/-/) {s8_pos=substr($(NF-1), 2); num_s8 = 0 - strtonum(s8_pos); }
  else {num_s8 = strtonum($(NF-1));}
  tmp8 = bits2str(num_s8, 8); 
  lui_ptn=BYTE_PTN[$NF];
  printf ".word\t0b%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, lui_ptn, "00", insn[$1,MINOR0], \
tmp8, xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
  if (match($1, "S32[NX]?OR")==1) {
  assert(match(tmp, "S32[NX]?ORXR([0-9]|1[0-5]),XR([0-9]|1[0-5]),XR([0-9]|1[0-5])$")==1, \
"syntax err");
  MXINSN_OK=1;
  printf ".word\t0b%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, "00000", insn[$1,MINOR0], xrf[$4], \
xrf[$3], xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
  if (match($1, "S32AND")==1) {
  assert(match(tmp, "S32ANDXR([0-9]|1[0-5]),XR([0-9]|1[0-5]),XR([0-9]|1[0-5])$")==1, \
"syntax err");
  MXINSN_OK=1;
  printf ".word\t0b%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, "00000", insn[$1,MINOR0], xrf[$4], \
xrf[$3], xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
  if (match($1, "S32EXTRV")==1) {
  if ($(NF-1) ~/[A-Z]/) {sub("[\$]","", $(NF-1)); $(NF-1)="$"grf[$(NF-1)];}
  if ($(NF) ~/[A-Z]/) {sub("[\$]","", $(NF)); $(NF)="$"grf[$(NF)];}
  {x_num=split(tmp,x_a); tmp=""; for(i=1;i&lt;x_num-1;i=i+1) {tmp=tmp""x_a[i]","}; 
  tmp=tmp""$(NF-1)","$NF;}
  assert(match(tmp, "S32EXTRVXR([0-9]|1[0-5]),XR([0-9]|1[0-5]),[\$]([12]?[0-9]|3[01]),\
[\$]([12]?[0-9]|3[01])$")==1, "syntax err");
  MXINSN_OK=1;
  rb=substr($(NF-1),2); grfb_num = bits2str(strtonum(rb), 5);
  rc=substr($(NF),2); grfc_num = bits2str(strtonum(rc), 5);
  printf ".word\t0b%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, grfb_num, grfc_num, "11", xrf[$3], \
  xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
  if (match($1, "S32EXTR")==1) {
  if ($(NF-1) ~/[A-Z]/) {sub("[\$]","", $(NF-1)); $(NF-1)="$"grf[$(NF-1)];
  x_num=split(tmp,x_a); tmp=""; for(i=1;i&lt;x_num-1;i=i+1) {tmp=tmp""x_a[i]","}; 
  tmp=tmp""$(NF-1)","$NF;}
  assert(match(tmp, "S32EXTRXR([0-9]|1[0-5]),XR([0-9]|1[0-5]),[\$]([12]?[0-9]|3[01]),\
(([12]?[0-9]|3[01])|0X[1]?[0-9A-F])$")==1, "syntax err");
  MXINSN_OK=1;
  rb=substr($(NF-1),2); grf_num = bits2str(strtonum(rb), 5);
  extr_bits = bits2str(strtonum($NF), 5);
  printf ".word\t0b%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, grf_num, extr_bits, "10", xrf[$3], \
  xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
  if (match($1, "S32MUL[U]?")==1) {
  if ($(NF-1) ~/[A-Z]/ ) {sub("[\$]","", $(NF-1)); $(NF-1)="$"grf[$(NF-1)]; }
  if ($(NF) ~/[A-Z]/ ) {sub("[\$]","", $(NF)); $(NF)="$"grf[$(NF)]; }
  { x_num=split(tmp,x_a); x_a[x_num-1]=$(NF-1); x_a[x_num]=$(NF); 
  tmp=""; for(i=1;i&lt;x_num;i=i+1) {tmp=tmp""x_a[i]","}; tmp=tmp""x_a[x_num]; }
  assert(match(tmp, "S32MUL[U]?XR([0-9]|1[0-5]),XR([0-9]|1[0-5]),[\$]([12]?[0-9]|3[01]),\
[\$]([12]?[0-9]|3[01])$")==1, "syntax err");
  MXINSN_OK=1;
  if ($1 ~/MULU/) mul_u = "01";
  else mul_u = "00";
  rb=substr($(NF-1),2); grf_rb = bits2str(strtonum(rb), 5);
  rc=substr($(NF),2); grf_rc = bits2str(strtonum(rc), 5);
  printf ".word\t0b%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, grf_rb, grf_rc, mul_u, xrf[$3], \
  xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
  if (match($1, "S32MADD[U]?")==1) {
  if ($(NF-1) ~/[A-Z]/ ) {sub("[\$]","", $(NF-1)); $(NF-1)="$"grf[$(NF-1)]; }
  if ($(NF) ~/[A-Z]/ ) {sub("[\$]","", $(NF)); $(NF)="$"grf[$(NF)]; }
  { x_num=split(tmp,x_a); x_a[x_num-1]=$(NF-1); x_a[x_num]=$(NF); 
  tmp=""; for(i=1;i&lt;x_num;i=i+1) {tmp=tmp""x_a[i]","}; tmp=tmp""x_a[x_num]; }
  assert(match(tmp, "S32MADD[U]?XR([0-9]|1[0-5]),XR([0-9]|1[0-5]),[\$]([12]?[0-9]|3[01]),\
[\$]([12]?[0-9]|3[01])$")==1, "syntax err");
  MXINSN_OK=1;
  rb=substr($(NF-1),2); grf_rb = bits2str(strtonum(rb), 5);
  rc=substr($(NF),2); grf_rc = bits2str(strtonum(rc), 5);
  printf ".word\t0b%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, grf_rb, grf_rc, "10", xrf[$3], \
  xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
  if (match($1, "S32MSUB[U]?")==1) {
  if ($(NF-1) ~/[A-Z]/ ) {sub("[\$]","", $(NF-1)); $(NF-1)="$"grf[$(NF-1)]; }
  if ($(NF) ~/[A-Z]/ ) {sub("[\$]","", $(NF)); $(NF)="$"grf[$(NF)]; }
  { x_num=split(tmp,x_a); x_a[x_num-1]=$(NF-1); x_a[x_num]=$(NF); 
  tmp=""; for(i=1;i&lt;x_num;i=i+1) {tmp=tmp""x_a[i]","}; tmp=tmp""x_a[x_num]; }
  assert(match(tmp, "S32MSUB[U]?XR([0-9]|1[0-5]),XR([0-9]|1[0-5]),[\$]([12]?[0-9]|3[01]),\
[\$]([12]?[0-9]|3[01])$")==1, "syntax err");
  MXINSN_OK=1;
  rb=substr($(NF-1),2); grf_rb = bits2str(strtonum(rb), 5);
  rc=substr($(NF),2); grf_rc = bits2str(strtonum(rc), 5);
  printf ".word\t0b%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, grf_rb, grf_rc, "10", xrf[$3], \
  xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
  if (match($1, "S32(M2I|I2M)")==1) {
  if ($NF ~/[A-Z]/) {sub("[\$]","", $NF); $NF="$"grf[$NF]; x_num=split(tmp,x_a); tmp=""; 
  for(i=1;i&lt;x_num;i=i+1) {tmp=tmp""x_a[i]","}; tmp=tmp""$NF;};
  assert(match(tmp, "S32(M2I|I2M)XR([0-9]|1[0-6]),[\$]([12]?[0-9]|3[01])$")==1,\
 "syntax err");
  MXINSN_OK=1;
  rb=substr($(NF),2); grf_num = bits2str(strtonum(rb), 5);
  if (match($2, "XR16")==1) Q32_XRA="10000";
  else Q32_XRA="0"xrf[$2];
  printf ".word\t0b%s%s%s%s%s%s\t\#%s\n", SPECIAL2, "00000", grf_num, "00000", \
Q32_XRA, insn[$1,EXTEND], $0; 
  next
  }
  if (match($1, "S32(LD[DI]|S(TD|DI))[V]?R")==1) {
  if ($1 ~/V/) {
  if ($(NF-2) ~/[A-Z]/ ) {sub("[\$]","", $(NF-2)); $(NF-2)="$"grf[$(NF-2)]; }
  if ($(NF-1) ~/[A-Z]/ ) {sub("[\$]","", $(NF-1)); $(NF-1)="$"grf[$(NF-1)]; }
  { x_num=split(tmp,x_a); x_a[x_num-1]=$(NF-1); x_a[x_num-2]=$(NF-2); 
  tmp=""; for(i=1;i&lt;=x_num-1;i=i+1) {tmp=tmp""x_a[i]","}; tmp=tmp""x_a[x_num]; }
  assert(match(tmp, "S32(LD[DI]|S(TD|DI))VRXR([0-9]|1[0-5]),[\$]([12]?[0-9]|3[01]),\
[\$]([12]?[0-9]|3[01]),([0-2]|0X[0-2])$")==1, "syntax err");
  MXINSN_OK=1;
  rb=substr($(NF-2),2); grfb_num = bits2str(strtonum(rb), 5);
  rc=substr($(NF-1),2); grfc_num = bits2str(strtonum(rc), 5);
  strd_num = bits2str(strtonum($NF), 2);
  printf ".word\t0b%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, grfb_num, grfc_num, strd_num, \
"0001", xrf[$2], insn[$1,EXTEND], $0; 
  next
  } else {
  if ($(NF-1) ~/[A-Z]/ ) {sub("[\$]","", $(NF-1)); $(NF-1)="$"grf[$(NF-1)]; }
  { x_num=split(tmp,x_a); x_a[x_num-1]=$(NF-1); tmp=""; 
  for(i=1;i&lt;=x_num-1;i=i+1) {tmp=tmp""x_a[i]","}; tmp=tmp""x_a[x_num]; }
  assert(match(tmp, "S32(LD[DI]|S(TD|DI))RXR([0-9]|1[0-5]),[\$]([12]?[0-9]|3[01]),\
[\-]?([0-9]+|0X[0-9A-F]+)$")==1, "syntax err");
  MXINSN_OK=1;
  rb=substr($(NF-1),2); grfb_num = bits2str(strtonum(rb), 5);
  if ($NF ~/-/) {s10_pos=substr($NF, 2); num_s10 = 0 - strtonum(s10_pos); }
  else num_s10 = strtonum($NF);
  S12 = bits2str(num_s10, 12); addr_off=substr(S12,1,10);
  printf ".word\t0b%s%s%s%s%s%s\t\#%s\n", SPECIAL2, grfb_num, "1", addr_off, \
xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
  }
  if (match($1, "S32(LD[DI]|S(TD|DI))[V]?")==1) {
  if ($1 ~/V/) {
  if ($(NF-2) ~/[A-Z]/ ) {sub("[\$]","", $(NF-2)); $(NF-2)="$"grf[$(NF-2)]; x_num=split(tmp,x_a); 
  tmp=""; for(i=1;i&lt;x_num-2;i=i+1) {tmp=tmp""x_a[i]","}; 
  tmp=tmp""$(NF-2)","x_a[x_num-1]","x_a[x_num];};
  if ($(NF-1) ~/[A-Z]/ ) {sub("[\$]","", $(NF-1)); $(NF-1)="$"grf[$(NF-1)]; x_num=split(tmp,x_a); 
  tmp=""; for(i=1;i&lt;x_num-1;i=i+1) {tmp=tmp""x_a[i]","}; tmp=tmp""$(NF-1)","x_a[x_num];};
  assert(match(tmp, "S32(LD[DI]|S(TD|DI))VXR([0-9]|1[0-5]),[\$]([12]?[0-9]|3[01]),\
[\$]([12]?[0-9]|3[01]),([0-2]|0X[0-2])$")==1, "syntax err");
  MXINSN_OK=1;
  rb=substr($(NF-2),2); grfb_num = bits2str(strtonum(rb), 5);
  rc=substr($(NF-1),2); grfc_num = bits2str(strtonum(rc), 5);
  strd_num = bits2str(strtonum($NF), 2);
  printf ".word\t0b%s%s%s%s%s%s%s\t\#%s\n", SPECIAL2, grfb_num, grfc_num, strd_num, \
"0000", xrf[$2], insn[$1,EXTEND], $0; 
  next
  } else {
  if ($(NF-1) ~/[A-Z]/ ) {sub("[\$]","", $(NF-1)); $(NF-1)="$"grf[$(NF-1)]; x_num=split(tmp,x_a); 
  tmp=""; for(i=1;i&lt;x_num-1;i=i+1) {tmp=tmp""x_a[i]","}; tmp=tmp""$(NF-1)","x_a[x_num];};
  assert(match(tmp, "S32(LD[DI]|S(TD|DI))XR([0-9]|1[0-5]),[\$]([12]?[0-9]|3[01]),\
[\-]?([0-9]+|0X[0-9A-F]+)$")==1, "syntax err");
  MXINSN_OK=1;
  rb=substr($(NF-1),2); grfb_num = bits2str(strtonum(rb), 5);
  if ($NF ~/-/) {s10_pos=substr($NF, 2); num_s10 = 0 - strtonum(s10_pos); }
  else num_s10 = strtonum($NF);
  S12 = bits2str(num_s10, 12); addr_off=substr(S12,1,10);
  printf ".word\t0b%s%s%s%s%s%s\t\#%s\n", SPECIAL2, grfb_num, "0", addr_off, \
xrf[$2], insn[$1,EXTEND], $0; 
  next
  }
  }
$0 = cur_line;
}
#&lt;---------------------------------------------------------------------------Others
  (MXINSN_OK == 0 || NF == 0) {print}

     function assert(condition, string)
     {
         if (!condition) {
             printf("%s: __line__%d: assertion failed: %s\n", FILENAME, FNR, string) 
             _assert_exit = 1
             exit 1
         }
     }

     function bits2str(bits, tail_len, zero, data, mask)
     {
         zero="0000000000000000";
         if (bits == 0) {
             zero=substr(zero, length(zero) - tail_len + 1, tail_len);
             return zero;
         }
         mask = 1;
         for (; bits != 0; bits = rshift(bits, 1))
             data = (and(bits, mask) ? "1" : "0") data;

         data=zero""data;         
         data=substr(data, length(data) - tail_len + 1, tail_len);         
         return data;
     }
     
     END {
         if (_assert_exit)
             exit 1
     }
' $1  2&gt;/dev/null
</pre><br>

<p>
<br><a href="../../handheld.htm">返回上一頁</a>
</p>

</div>
</div>
</div>
</body>
</html>
